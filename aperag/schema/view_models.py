# Copyright 2025 ApeCloud, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# generated by datamodel-codegen:
#   filename:  openapi.merged.yaml
#   timestamp: 2025-07-09T15:44:42+00:00

from __future__ import annotations

from datetime import datetime
from typing import Any, Literal, Optional, Union

from pydantic import BaseModel, EmailStr, Extra, Field, confloat, conint


class Bot(BaseModel):
    id: Optional[str] = None
    title: Optional[str] = None
    description: Optional[str] = None
    type: Optional[Literal['knowledge', 'common']] = None
    config: Optional[str] = None
    collection_ids: Optional[list[str]] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None


class PageResult(BaseModel):
    """
    PageResult info
    """

    page_number: Optional[int] = Field(None, description='The page number')
    page_size: Optional[int] = Field(None, description='The page size')
    count: Optional[int] = Field(None, description='The total count of items')


class BotList(BaseModel):
    """
    A list of bots
    """

    items: Optional[list[Bot]] = None
    pageResult: Optional[PageResult] = None


class FailResponse(BaseModel):
    code: Optional[str] = Field(None, description='Error code', example='400')
    message: Optional[str] = Field(
        None, description='Error message', example='Invalid request'
    )


class BotCreate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    type: Optional[Literal['knowledge', 'common']] = None
    config: Optional[str] = None
    collection_ids: Optional[list[str]] = None


class BotUpdate(BaseModel):
    id: Optional[str] = None
    title: Optional[str] = None
    description: Optional[str] = None
    type: Optional[Literal['knowledge', 'common']] = None
    config: Optional[str] = None
    collection_ids: Optional[list[str]] = None


class Retry(BaseModel):
    max_attempts: Optional[int] = Field(
        None, description='Maximum number of retry attempts', example=3
    )
    delay: Optional[int] = Field(
        None, description='Delay between retries in seconds', example=5
    )


class Notification(BaseModel):
    email: Optional[list[EmailStr]] = Field(None, example=['admin@example.com'])


class ErrorHandling(BaseModel):
    strategy: Optional[Literal['stop_on_error', 'continue_on_error']] = Field(
        None, description='Error handling strategy', example='stop_on_error'
    )
    notification: Optional[Notification] = None


class ExecutionConfig(BaseModel):
    """
    Configuration for workflow execution
    """

    timeout: Optional[int] = Field(
        None, description='Overall timeout in seconds', example=300
    )
    retry: Optional[Retry] = None
    error_handling: Optional[ErrorHandling] = None


class SchemaDefinition(BaseModel):
    """
    JSON Schema definition
    """

    class Config:
        extra = Extra.allow

    type: Optional[
        Literal['object', 'array', 'string', 'number', 'integer', 'boolean']
    ] = None
    properties: Optional[dict[str, Any]] = None
    required: Optional[list[str]] = None
    additionalProperties: Optional[bool] = None


class Input(BaseModel):
    schema_: SchemaDefinition = Field(..., alias='schema')
    values: Optional[dict[str, Any]] = Field(
        None, description='Default values and template references'
    )


class Output(BaseModel):
    schema_: SchemaDefinition = Field(..., alias='schema')


class Data(BaseModel):
    input: Input
    output: Output
    collapsed: Optional[bool] = Field(
        None,
        description='Whether the node is collapsed, only useful for frontend to collapse the node',
        example=False,
    )


class Position(BaseModel):
    """
    Position of the node in the frontend
    """

    x: Optional[float] = None
    y: Optional[float] = None


class Measured(BaseModel):
    """
    Measured position of the node, only useful for frontend to measure the node
    """

    width: Optional[float] = None
    height: Optional[float] = None


class Node(BaseModel):
    id: str = Field(
        ...,
        description='Unique identifier for the node',
        example='vector_search_3f8e2c1a',
    )
    ariaLabel: Optional[str] = Field(None, description='label for the node')
    type: Literal[
        'start',
        'vector_search',
        'fulltext_search',
        'graph_search',
        'merge',
        'rerank',
        'llm',
    ] = Field(..., description='Type of node', example='vector_search')
    title: Optional[str] = Field(
        None, description='Human-readable title of the node', example='Vector Search'
    )
    data: Data
    position: Optional[Position] = Field(
        None, description='Position of the node in the frontend'
    )
    dragHandle: Optional[str] = Field(
        None,
        description='Drag handle of the node, only useful for frontend to drag the node',
    )
    measured: Optional[Measured] = Field(
        None,
        description='Measured position of the node, only useful for frontend to measure the node',
    )
    selected: Optional[bool] = Field(
        None,
        description='Whether the node is selected, only useful for frontend to select the node',
    )
    deletable: Optional[bool] = Field(
        None,
        description='Whether the node is deletable, only useful for frontend to delete the node',
        example=True,
    )


class Edge(BaseModel):
    id: Optional[str] = Field(
        None,
        description='Unique identifier for the edge, only useful for frontend to identify the edge',
        example='edge_1',
    )
    deletable: Optional[bool] = Field(
        None,
        description='Whether the edge is deletable, only useful for frontend to delete the edge',
        example=True,
    )
    type: Optional[str] = Field(None, description='Type of the edge', example='edge')
    source: str = Field(..., description='ID of the source node', example='start')
    target: str = Field(
        ..., description='ID of the target node', example='vector_search_3f8e2c1a'
    )


class WorkflowStyle(BaseModel):
    """
    Workflow style
    """

    edgeType: Optional[
        Literal['straight', 'step', 'smoothstep', 'default', 'simplebezier']
    ] = None
    layoutDirection: Optional[Literal['TB', 'LR']] = None


class WorkflowDefinition(BaseModel):
    name: str = Field(
        ...,
        description='Machine-readable identifier for the workflow',
        example='rag_flow',
    )
    title: str = Field(
        ...,
        description='Human-readable title of the workflow',
        example='RAG Knowledge Base Flow',
    )
    description: Optional[str] = Field(
        None,
        description='Detailed description of the workflow',
        example='A typical RAG flow with parallel retrieval and reranking',
    )
    version: str = Field(
        ..., description='Version number of the workflow definition', example='1.0.0'
    )
    execution: Optional[ExecutionConfig] = None
    schema_: Optional[dict[str, SchemaDefinition]] = Field(
        None,
        alias='schema',
        description='Custom schema definitions used across the workflow',
    )
    nodes: list[Node] = Field(..., description='List of nodes in the workflow')
    edges: list[Edge] = Field(
        ..., description='List of edges connecting nodes in the workflow'
    )
    style: Optional[WorkflowStyle] = None


class DebugFlowRequest(BaseModel):
    query: str


class Chat(BaseModel):
    id: Optional[str] = None
    title: Optional[str] = None
    bot_id: Optional[str] = None
    peer_id: Optional[str] = None
    peer_type: Optional[
        Literal['system', 'feishu', 'weixin', 'weixin_official', 'web', 'dingtalk']
    ] = None
    status: Optional[Literal['active', 'archived']] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None


class ChatList(BaseModel):
    """
    A list of chats
    """

    items: Optional[list[Chat]] = None
    pageResult: Optional[PageResult] = None


class ChatCreate(BaseModel):
    title: Optional[str] = None


class Reference(BaseModel):
    score: Optional[float] = None
    text: Optional[str] = None
    metadata: Optional[dict[str, Any]] = None


class Feedback(BaseModel):
    type: Optional[Literal['good', 'bad']] = None
    tag: Optional[Literal['Harmful', 'Unsafe', 'Fake', 'Unhelpful', 'Other']] = None
    message: Optional[str] = None


class ChatMessage(BaseModel):
    id: Optional[str] = None
    type: Optional[Literal['welcome', 'message', 'start', 'stop', 'error']] = None
    timestamp: Optional[float] = None
    role: Optional[Literal['human', 'ai']] = None
    data: Optional[str] = None
    references: Optional[list[Reference]] = None
    urls: Optional[list[str]] = None
    feedback: Optional[Feedback] = None


class ChatDetails(BaseModel):
    id: Optional[str] = None
    title: Optional[str] = None
    bot_id: Optional[str] = None
    peer_id: Optional[str] = None
    peer_type: Optional[
        Literal['system', 'feishu', 'weixin', 'weixin_official', 'web', 'dingtalk']
    ] = None
    history: Optional[list[ChatMessage]] = None
    status: Optional[Literal['active', 'archived']] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None


class ChatUpdate(BaseModel):
    title: Optional[str] = None


class CrontabConfig(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='Whether to enable scheduled tasks'
    )
    minute: Optional[str] = Field(
        None, description='Minute field in cron expression', example='0'
    )
    hour: Optional[str] = Field(
        None, description='Hour field in cron expression', example='0'
    )
    day_of_month: Optional[str] = Field(
        None, description='Day of month field in cron expression', example='*'
    )
    month: Optional[str] = Field(
        None, description='Month field in cron expression', example='*'
    )
    day_of_week: Optional[str] = Field(
        None, description='Day of week field in cron expression', example='*'
    )


class ModelSpec(BaseModel):
    model: Optional[str] = Field(
        None, description='The name of the language model to use', example='gpt-4o-mini'
    )
    model_service_provider: Optional[str] = Field(
        None,
        description='Used for querying auth information (api_key/api_base/...) for a model service provider.',
        example='openai',
    )
    custom_llm_provider: Optional[str] = Field(
        None,
        description="Used for Non-OpenAI LLMs (e.g. 'bedrock' for amazon.titan-tg1-large)",
        example='openai',
    )
    temperature: Optional[confloat(ge=0.0, le=2.0)] = Field(
        0.1,
        description='Controls randomness in the output. Values between 0 and 2. Lower values make output more focused and deterministic',
        example=0.1,
    )
    max_tokens: Optional[conint(ge=1)] = Field(
        None, description='Maximum number of tokens to generate', example=4096
    )
    max_completion_tokens: Optional[conint(ge=1)] = Field(
        None,
        description='Upper bound for generated completion tokens, including visible and reasoning tokens',
        example=4096,
    )
    timeout: Optional[conint(ge=1)] = Field(
        None, description='Maximum execution time in seconds for the API request'
    )
    top_n: Optional[conint(ge=1)] = Field(
        None, description='Number of top results to return when reranking documents'
    )
    tags: Optional[list[str]] = Field(
        [], description='Tags for model categorization', example=['free', 'recommend']
    )


class ParserConfig(BaseModel):
    use_mineru: Optional[bool] = Field(None, description='Whether to use MinerU parser')
    mineru_api_token: Optional[str] = Field(None, description='MinerU API token')


class CollectionConfig(BaseModel):
    source: Optional[str] = Field(
        None, description='Source system identifier', example='system'
    )
    crontab: Optional[CrontabConfig] = None
    enable_knowledge_graph: Optional[bool] = Field(
        None, description='Whether to enable knowledge graph'
    )
    embedding: Optional[ModelSpec] = None
    completion: Optional[ModelSpec] = None
    parser: Optional[ParserConfig] = None
    path: Optional[str] = Field(None, description='Path for local and ftp sources')
    host: Optional[str] = Field(None, description='FTP host')
    username: Optional[str] = Field(None, description='FTP username')
    password: Optional[str] = Field(None, description='FTP password')
    region: Optional[str] = Field(None, description='Region for S3/OSS')
    access_key_id: Optional[str] = Field(None, description='Access key ID for S3/OSS')
    secret_access_key: Optional[str] = Field(
        None, description='Secret access key for S3/OSS'
    )
    bucket: Optional[str] = Field(None, description='Bucket name for S3/OSS')
    dir: Optional[str] = Field(None, description='Directory path in bucket for S3/OSS')
    email_source: Optional[dict[str, Any]] = Field(
        None, description='Email source configuration'
    )
    pop_server: Optional[str] = Field(None, description='POP3 server address')
    port: Optional[str] = Field(None, description='Email server port')
    email_address: Optional[str] = Field(None, description='Email address')
    email_password: Optional[str] = Field(None, description='Email password')
    app_id: Optional[str] = Field(None, description='Feishu app ID')
    app_secret: Optional[str] = Field(None, description='Feishu app secret')
    space_id: Optional[str] = Field(None, description='Feishu space ID')


class Local(BaseModel):
    path: Optional[str] = None


class Bucket(BaseModel):
    bucket: Optional[str] = None
    dir: Optional[str] = None


class Oss(BaseModel):
    access_key_id: Optional[str] = None
    access_key_secret: Optional[str] = None
    buckets: Optional[list[Bucket]] = None
    bucket: Optional[str] = None
    endpoint: Optional[str] = None
    region: Optional[str] = None
    dir: Optional[str] = None


class S3(BaseModel):
    access_key_id: Optional[str] = None
    access_key_secret: Optional[str] = None
    buckets: Optional[list[dict[str, Any]]] = None
    bucket: Optional[str] = None
    region: Optional[str] = None
    dir: Optional[str] = None


class Ftp(BaseModel):
    path: Optional[str] = None
    host: Optional[str] = None
    port: Optional[float] = None
    username: Optional[str] = None


class Email(BaseModel):
    pop_server: Optional[str] = None
    port: Optional[float] = None
    email_address: Optional[str] = None
    email_password: Optional[str] = None
    detect_spam: Optional[bool] = None


class Url(BaseModel):
    url: Optional[str] = None
    name: Optional[str] = None


class Feishu(BaseModel):
    app_id: Optional[str] = None
    app_secret: Optional[str] = None
    space_id: Optional[str] = None
    node_id: Optional[str] = None
    method: Optional[str] = None
    target_format: Optional[str] = None


class CollectionSource(BaseModel):
    category: Optional[
        Literal[
            'upload', 'tencent', 'oss', 'local', 's3', 'ftp', 'email', 'url', 'github'
        ]
    ] = None
    upload: Optional[dict[str, Any]] = None
    local: Optional[Local] = None
    oss: Optional[Oss] = None
    s3: Optional[S3] = None
    ftp: Optional[Ftp] = None
    email: Optional[Email] = None
    url: Optional[Url] = None
    feishu: Optional[Feishu] = None


class Collection(BaseModel):
    """
    Collection is a collection of documents
    """

    id: Optional[str] = None
    title: Optional[str] = None
    type: Optional[str] = None
    description: Optional[str] = None
    config: Optional[CollectionConfig] = None
    source: Optional[CollectionSource] = None
    status: Optional[Literal['ACTIVE', 'INACTIVE', 'DELETED']] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None


class CollectionList(BaseModel):
    """
    A list of collections
    """

    items: Optional[list[Collection]] = None
    pageResult: Optional[PageResult] = None


class CollectionCreate(BaseModel):
    title: Optional[str] = None
    config: Optional[CollectionConfig] = None
    type: Optional[str] = None
    description: Optional[str] = None
    source: Optional[CollectionSource] = None


class CollectionUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    config: Optional[CollectionConfig] = None
    source: Optional[CollectionSource] = None


class Document(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    status: Optional[
        Literal['PENDING', 'RUNNING', 'COMPLETE', 'FAILED', 'DELETING', 'DELETED']
    ] = None
    vector_index_status: Optional[
        Literal[
            'PENDING',
            'CREATING',
            'ACTIVE',
            'DELETING',
            'DELETION_IN_PROGRESS',
            'FAILED',
            'SKIPPED',
        ]
    ] = None
    fulltext_index_status: Optional[
        Literal[
            'PENDING',
            'CREATING',
            'ACTIVE',
            'DELETING',
            'DELETION_IN_PROGRESS',
            'FAILED',
            'SKIPPED',
        ]
    ] = None
    graph_index_status: Optional[
        Literal[
            'PENDING',
            'CREATING',
            'ACTIVE',
            'DELETING',
            'DELETION_IN_PROGRESS',
            'FAILED',
            'SKIPPED',
        ]
    ] = None
    vector_index_updated: Optional[datetime] = Field(
        None, description='Vector index last updated time'
    )
    fulltext_index_updated: Optional[datetime] = Field(
        None, description='Fulltext index last updated time'
    )
    graph_index_updated: Optional[datetime] = Field(
        None, description='Graph index last updated time'
    )
    config: Optional[str] = None
    size: Optional[float] = None
    created: Optional[datetime] = None
    updated: Optional[datetime] = None


class DocumentList(BaseModel):
    """
    A list of documents
    """

    items: Optional[list[Document]] = None
    pageResult: Optional[PageResult] = None


class DocumentCreate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    source: Optional[str] = None
    collection_id: Optional[str] = None


class RebuildIndexesRequest(BaseModel):
    index_types: list[Literal['VECTOR', 'FULLTEXT', 'GRAPH']] = Field(
        ..., description='Types of indexes to rebuild', min_items=1
    )


class Chunk(BaseModel):
    id: Optional[str] = None
    text: Optional[str] = None
    metadata: Optional[dict[str, Any]] = None


class DocumentPreview(BaseModel):
    doc_object_path: Optional[str] = Field(
        None, description='The path to the document object.'
    )
    doc_filename: Optional[str] = Field(None, description='The name of the document.')
    converted_pdf_object_path: Optional[str] = Field(
        None, description='The path to the converted PDF object.'
    )
    markdown_content: Optional[str] = Field(
        None, description='The markdown content of the document.'
    )
    chunks: Optional[list[Chunk]] = None


class VectorSearchParams(BaseModel):
    topk: Optional[int] = Field(None, description='Top K results')
    similarity: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None, description='Similarity threshold'
    )


class FulltextSearchParams(BaseModel):
    topk: Optional[int] = Field(None, description='Top K results')


class GraphSearchParams(BaseModel):
    topk: Optional[int] = Field(None, description='Top K results')


class SearchResultItem(BaseModel):
    rank: Optional[int] = Field(None, description='Result rank')
    score: Optional[float] = Field(None, description='Result score')
    content: Optional[str] = Field(None, description='Result content')
    source: Optional[str] = Field(None, description='Source document or metadata')
    recall_type: Optional[
        Literal['vector_search', 'graph_search', 'fulltext_search']
    ] = Field(None, description='Recall type')


class SearchResult(BaseModel):
    id: Optional[str] = Field(None, description='The id of the search result')
    query: Optional[str] = None
    vector_search: Optional[VectorSearchParams] = None
    fulltext_search: Optional[FulltextSearchParams] = None
    graph_search: Optional[GraphSearchParams] = None
    items: Optional[list[SearchResultItem]] = None
    created: Optional[datetime] = Field(
        None, description='The creation time of the search result'
    )


class SearchResultList(BaseModel):
    """
    A list of search results
    """

    items: Optional[list[SearchResult]] = None


class SearchRequest(BaseModel):
    """
    Search request
    """

    query: Optional[str] = None
    vector_search: Optional[VectorSearchParams] = None
    fulltext_search: Optional[FulltextSearchParams] = None
    graph_search: Optional[GraphSearchParams] = None


class GraphLabelsResponse(BaseModel):
    """
    Response containing available graph labels
    """

    labels: list[str] = Field(
        ...,
        description='List of available node labels in the knowledge graph',
        example=['墨香居', '李明华', '林晓雯', '深夜读书会'],
    )


class Properties(BaseModel):
    """
    Node properties containing entity metadata
    """

    class Config:
        extra = Extra.allow

    entity_id: Optional[str] = Field(
        None, description='Entity identifier', example='墨香居'
    )
    entity_type: Optional[str] = Field(
        None, description='Type of the entity', example='organization'
    )
    description: Optional[str] = Field(
        None,
        description='Description of the entity',
        example='墨香居是这条老巷子里唯一的旧书店，经营着各种书籍，承载了老板李明华的情怀。',
    )
    source_id: Optional[str] = Field(
        None,
        description='Source chunk ID where entity was extracted',
        example='chunk-88845945407136e9498f5f594c8a00c6',
    )
    file_path: Optional[str] = Field(
        None, description='Source file path', example='story.txt'
    )
    created_at: Optional[int] = Field(
        None, description='Creation timestamp', example=1751356233
    )


class GraphNode(BaseModel):
    """
    Knowledge graph node representing an entity
    """

    id: str = Field(
        ...,
        description='Unique identifier for the node (entity name)',
        example='墨香居',
    )
    labels: list[str] = Field(
        ..., description='Labels associated with the node', example=['墨香居']
    )
    properties: Properties = Field(
        ..., description='Node properties containing entity metadata'
    )


class Properties1(BaseModel):
    """
    Edge properties containing relationship metadata
    """

    class Config:
        extra = Extra.allow

    weight: Optional[float] = Field(
        None, description='Relationship weight/strength', example=9
    )
    description: Optional[str] = Field(
        None,
        description='Description of the relationship',
        example='深夜读书会是墨香居的新活动，旨在提升书店的活力和吸引顾客。',
    )
    keywords: Optional[str] = Field(
        None,
        description='Keywords associated with the relationship',
        example='书店活力,活动',
    )
    source_id: Optional[str] = Field(
        None,
        description='Source chunk ID where relationship was extracted',
        example='chunk-88845945407136e9498f5f594c8a00c6',
    )
    file_path: Optional[str] = Field(
        None, description='Source file path', example='story.txt'
    )
    created_at: Optional[int] = Field(
        None, description='Creation timestamp', example=1751356233
    )


class GraphEdge(BaseModel):
    """
    Knowledge graph edge representing a relationship
    """

    id: str = Field(
        ..., description='Unique identifier for the edge', example='墨香居-深夜读书会'
    )
    type: Optional[str] = Field(
        'DIRECTED', description='Type of the relationship', example='DIRECTED'
    )
    source: str = Field(..., description='Source node ID', example='墨香居')
    target: str = Field(..., description='Target node ID', example='深夜读书会')
    properties: Properties1 = Field(
        ..., description='Edge properties containing relationship metadata'
    )


class KnowledgeGraph(BaseModel):
    """
    Knowledge graph containing nodes and edges
    """

    nodes: list[GraphNode] = Field(
        ..., description='List of nodes in the knowledge graph'
    )
    edges: list[GraphEdge] = Field(
        ..., description='List of edges in the knowledge graph'
    )
    is_truncated: bool = Field(
        ...,
        description='Whether the graph was truncated due to size limits',
        example=False,
    )


class TargetEntityData(BaseModel):
    """
    Optional target entity configuration. If not specified or empty, auto-select entity with highest degree
    """

    entity_name: Optional[str] = Field(
        None,
        description='Target entity name. If not specified, auto-select entity with highest degree',
        example='墨香居',
    )
    entity_type: Optional[str] = Field(
        None, description='Entity type for the target entity', example='ORGANIZATION'
    )
    description: Optional[str] = Field(
        None,
        description='Description for the target entity',
        example='A comprehensive bookstore and cultural space',
    )
    source_id: Optional[str] = Field(
        None, description='Source ID for the target entity'
    )
    file_path: Optional[str] = Field(
        None, description='File path for the target entity'
    )


class NodeMergeRequest(BaseModel):
    """
    Request to merge multiple graph nodes
    """

    class Config:
        extra = Extra.forbid

    entity_ids: list[str] = Field(
        ...,
        description='List of entity IDs to merge (supports 1 or more entities)',
        example=['墨香居', '书店', '旧书店'],
        min_items=1,
    )
    target_entity_data: Optional[TargetEntityData] = Field(
        None,
        description='Optional target entity configuration. If not specified or empty, auto-select entity with highest degree',
    )


class TargetEntityData1(BaseModel):
    """
    Complete data of the target entity after merge
    """

    entity_name: str = Field(
        ...,
        description='The entity name that was kept (merge target)',
        example='墨香居',
    )
    entity_type: str = Field(
        ..., description='Entity type of the target entity', example='ORGANIZATION'
    )
    description: str = Field(
        ...,
        description='Merged description of the target entity',
        example='墨香居是这条老巷子里唯一的旧书店，经营着各种书籍，承载了老板李明华的情怀。',
    )
    source_id: Optional[str] = Field(
        None, description='Source ID information', example='chunk-001,chunk-002'
    )
    file_path: Optional[str] = Field(
        None, description='File path information', example='story.txt,book.txt'
    )


class NodeMergeResponse(BaseModel):
    """
    Response containing node merge results
    """

    status: Literal['success', 'error'] = Field(
        ..., description='Status of the merge operation', example='success'
    )
    message: str = Field(
        ...,
        description='Detailed message about the merge operation',
        example='Successfully merged 2 entities into 墨香居',
    )
    target_entity_data: TargetEntityData1 = Field(
        ..., description='Complete data of the target entity after merge'
    )
    source_entities: list[str] = Field(
        ...,
        description='List of entities that were merged into the target',
        example=['书店', '旧书店'],
    )
    redirected_edges: conint(ge=0) = Field(
        ..., description='Number of edges that were redirected during merge', example=12
    )
    merged_description_length: conint(ge=0) = Field(
        ..., description='Length of the merged description', example=512
    )
    used_llm_summary: bool = Field(
        ..., description='Whether LLM was used to summarize descriptions', example=True
    )
    collection_id: Optional[str] = Field(
        None,
        description='Collection ID where the merge was performed',
        example='col_12345',
    )


class ApiKey(BaseModel):
    id: Optional[str] = None
    key: Optional[str] = None
    description: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    last_used_at: Optional[datetime] = None


class ApiKeyList(BaseModel):
    """
    A list of API keys
    """

    items: Optional[list[ApiKey]] = None
    pageResult: Optional[PageResult] = None


class ApiKeyCreate(BaseModel):
    description: Optional[str] = None


class ApiKeyUpdate(BaseModel):
    description: Optional[str] = None


class TagFilterCondition(BaseModel):
    operation: Literal['AND', 'OR'] = Field(
        ..., description='Logical operation for tags in this condition', example='AND'
    )
    tags: list[str] = Field(
        ...,
        description='List of tags for this condition',
        example=['free', 'recommend'],
    )


class TagFilterRequest(BaseModel):
    """
    Tag filtering request. Empty request body or empty tag_filters returns recommend models by default.
    """

    tag_filters: Optional[list[TagFilterCondition]] = Field(
        None,
        description='List of tag filter conditions (OR relationship between conditions). If not provided or empty, returns models with "recommend" tag by default.',
        example=[
            {'operation': 'AND', 'tags': ['free', 'recommend']},
            {'operation': 'OR', 'tags': ['openai', 'gpt']},
        ],
    )


class ModelConfig(BaseModel):
    name: Optional[str] = None
    completion_dialect: Optional[str] = None
    embedding_dialect: Optional[str] = None
    rerank_dialect: Optional[str] = None
    label: Optional[str] = None
    allow_custom_base_url: Optional[bool] = None
    base_url: Optional[str] = None
    embedding: Optional[list[ModelSpec]] = None
    completion: Optional[list[ModelSpec]] = None
    rerank: Optional[list[ModelSpec]] = None


class ModelConfigList(BaseModel):
    items: Optional[list[ModelConfig]] = None
    pageResult: Optional[PageResult] = None


class LlmProvider(BaseModel):
    name: str = Field(
        ..., description='Unique provider name identifier', example='openai'
    )
    user_id: str = Field(
        ...,
        description='User ID of the provider owner, "public" for system providers',
        example='public',
    )
    label: str = Field(
        ..., description='Human-readable provider display name', example='OpenAI'
    )
    completion_dialect: Optional[str] = Field(
        'openai', description='API dialect for completion/chat APIs', example='openai'
    )
    embedding_dialect: Optional[str] = Field(
        'openai', description='API dialect for embedding APIs', example='openai'
    )
    rerank_dialect: Optional[str] = Field(
        'jina_ai', description='API dialect for rerank APIs', example='jina_ai'
    )
    allow_custom_base_url: Optional[bool] = Field(
        False, description='Whether custom base URLs are allowed'
    )
    base_url: str = Field(
        ...,
        description='Default API base URL for this provider',
        example='https://api.openai.com/v1',
    )
    extra: Optional[str] = Field(
        None, description='Additional configuration data in JSON format'
    )
    api_key: Optional[str] = Field(
        None, description='API key for this provider (if configured by user)'
    )
    created: Optional[datetime] = Field(None, description='Creation timestamp')
    updated: Optional[datetime] = Field(None, description='Last update timestamp')


class LlmProviderModel(BaseModel):
    provider_name: str = Field(
        ..., description='Reference to LLMProvider.name', example='openai'
    )
    api: Literal['completion', 'embedding', 'rerank'] = Field(
        ..., description='API type for this model', example='completion'
    )
    model: str = Field(..., description='Model name/identifier', example='gpt-4o-mini')
    custom_llm_provider: str = Field(
        ..., description='Custom LLM provider implementation', example='openai'
    )
    context_window: Optional[int] = Field(
        None, description='Context window size (total tokens)', example=128000
    )
    max_input_tokens: Optional[int] = Field(
        None, description='Maximum input tokens', example=120000
    )
    max_output_tokens: Optional[int] = Field(
        None, description='Maximum output tokens', example=8000
    )
    tags: Optional[list[str]] = Field(
        [], description='Tags for model categorization', example=['free', 'recommend']
    )
    created: Optional[datetime] = Field(None, description='Creation timestamp')
    updated: Optional[datetime] = Field(None, description='Last update timestamp')


class LlmConfigurationResponse(BaseModel):
    providers: list[LlmProvider] = Field(..., description='List of LLM providers')
    models: list[LlmProviderModel] = Field(
        ..., description='List of LLM provider models'
    )


class LlmProviderCreateWithApiKey(BaseModel):
    name: Optional[str] = Field(
        None,
        description='Unique provider name identifier (auto-generated if not provided)',
    )
    label: str = Field(..., description='Human-readable provider display name')
    completion_dialect: Optional[str] = Field(
        'openai', description='API dialect for completion/chat APIs'
    )
    embedding_dialect: Optional[str] = Field(
        'openai', description='API dialect for embedding APIs'
    )
    rerank_dialect: Optional[str] = Field(
        'jina_ai', description='API dialect for rerank APIs'
    )
    allow_custom_base_url: Optional[bool] = Field(
        False, description='Whether custom base URLs are allowed'
    )
    base_url: str = Field(..., description='Default API base URL for this provider')
    extra: Optional[str] = Field(
        None, description='Additional configuration data in JSON format'
    )
    api_key: Optional[str] = Field(
        None, description='Optional API key for this provider'
    )
    status: Optional[Literal['enable', 'disable']] = Field(
        None,
        description='Provider status - enable to create/update API key, disable to remove API key',
    )


class LlmProviderUpdateWithApiKey(BaseModel):
    label: Optional[str] = Field(
        None, description='Human-readable provider display name'
    )
    completion_dialect: Optional[str] = Field(
        None, description='API dialect for completion/chat APIs'
    )
    embedding_dialect: Optional[str] = Field(
        None, description='API dialect for embedding APIs'
    )
    rerank_dialect: Optional[str] = Field(
        None, description='API dialect for rerank APIs'
    )
    allow_custom_base_url: Optional[bool] = Field(
        None, description='Whether custom base URLs are allowed'
    )
    base_url: Optional[str] = Field(
        None, description='Default API base URL for this provider'
    )
    extra: Optional[str] = Field(
        None, description='Additional configuration data in JSON format'
    )
    api_key: Optional[str] = Field(
        None, description='Optional API key for this provider'
    )
    status: Optional[Literal['enable', 'disable']] = Field(
        None,
        description='Provider status - enable to create/update API key, disable to remove API key',
    )


class LlmProviderModelList(BaseModel):
    items: Optional[list[LlmProviderModel]] = None
    pageResult: Optional[PageResult] = None


class LlmProviderModelCreate(BaseModel):
    provider_name: str = Field(..., description='Reference to LLMProvider.name')
    api: Literal['completion', 'embedding', 'rerank'] = Field(
        ..., description='API type for this model'
    )
    model: str = Field(..., description='Model name/identifier')
    custom_llm_provider: str = Field(
        ..., description='Custom LLM provider implementation'
    )
    context_window: Optional[int] = Field(
        None, description='Context window size (total tokens)', example=128000
    )
    max_input_tokens: Optional[int] = Field(
        None, description='Maximum input tokens', example=120000
    )
    max_output_tokens: Optional[int] = Field(
        None, description='Maximum output tokens', example=8000
    )
    tags: Optional[list[str]] = Field([], description='Tags for model categorization')


class LlmProviderModelUpdate(BaseModel):
    custom_llm_provider: Optional[str] = Field(
        None, description='Custom LLM provider implementation'
    )
    context_window: Optional[int] = Field(
        None, description='Context window size (total tokens)', example=128000
    )
    max_input_tokens: Optional[int] = Field(
        None, description='Maximum input tokens', example=120000
    )
    max_output_tokens: Optional[int] = Field(
        None, description='Maximum output tokens', example=8000
    )
    tags: Optional[list[str]] = Field(None, description='Tags for model categorization')


class EmbeddingRequest(BaseModel):
    """
    Request to generate embeddings for text inputs
    """

    provider: str = Field(
        ..., description='LLM provider name (e.g., openai, anthropic)', example='openai'
    )
    model: str = Field(
        ...,
        description='Model name for embedding generation',
        example='text-embedding-3-small',
    )
    input: Union[str, list[str]]


class EmbeddingData(BaseModel):
    """
    Individual embedding result
    """

    object: str = Field(..., description='Object type identifier', example='embedding')
    embedding: list[float] = Field(
        ...,
        description='The embedding vector as a list of floats',
        example=[0.0023064255, -0.009327292, 0.015797421, 0.0012345678],
    )
    index: int = Field(
        ...,
        description='Index of the input text corresponding to this embedding',
        example=0,
    )


class EmbeddingUsage(BaseModel):
    """
    Token usage information for the embedding request
    """

    prompt_tokens: int = Field(
        ..., description='Number of tokens in the input text(s)', example=16
    )
    total_tokens: int = Field(
        ...,
        description='Total number of tokens used (same as prompt_tokens for embeddings)',
        example=16,
    )


class EmbeddingResponse(BaseModel):
    """
    Response containing generated embeddings in OpenAI-compatible format
    """

    object: str = Field(..., description='Object type identifier', example='list')
    data: list[EmbeddingData] = Field(..., description='List of embedding results')
    model: str = Field(
        ...,
        description='Model used for embedding generation',
        example='text-embedding-3-small',
    )
    usage: EmbeddingUsage


class Document1(BaseModel):
    text: str = Field(
        ...,
        description='Document text content',
        example='Paris is the capital of France.',
    )
    metadata: Optional[dict[str, Any]] = Field(
        None,
        description='Optional document metadata',
        example={'id': 'doc_123', 'source': 'wikipedia'},
    )


class RerankRequest(BaseModel):
    """
    Request to rerank documents based on query relevance
    """

    provider: str = Field(
        ..., description='LLM provider name (e.g., cohere, jina_ai)', example='cohere'
    )
    model: str = Field(
        ..., description='Model name for reranking', example='rerank-english-v3.0'
    )
    query: str = Field(
        ...,
        description='Search query to rank documents against',
        example='What is the capital of France?',
    )
    documents: Union[list[str], list[Document1]]
    top_k: Optional[conint(ge=1, le=1000)] = Field(
        10, description='Maximum number of top-ranked documents to return', example=3
    )
    return_documents: Optional[bool] = Field(
        True, description='Whether to return document content in response', example=True
    )


class Document2(BaseModel):
    """
    Document content and metadata (only present if return_documents=true)
    """

    text: str = Field(
        ...,
        description='Document text content',
        example='Paris is the capital of France.',
    )
    metadata: Optional[dict[str, Any]] = Field(
        None,
        description='Document metadata if provided in the request',
        example={'id': 'doc_123', 'source': 'wikipedia'},
    )


class RerankDocument(BaseModel):
    """
    Individual reranked document result
    """

    index: int = Field(
        ..., description='Original index of the document in the input array', example=0
    )
    relevance_score: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description='Relevance score between 0 and 1 (higher is more relevant)',
        example=0.95,
    )
    document: Optional[Document2] = Field(
        None,
        description='Document content and metadata (only present if return_documents=true)',
    )


class RerankUsage(BaseModel):
    """
    Token usage information for the rerank request
    """

    total_tokens: int = Field(
        ...,
        description='Total number of tokens processed (query + all documents)',
        example=156,
    )


class RerankResponse(BaseModel):
    """
    Response containing reranked documents in industry-standard format
    """

    object: str = Field(..., description='Object type identifier', example='list')
    data: list[RerankDocument] = Field(
        ...,
        description='List of reranked documents ordered by relevance (highest first)',
    )
    model: str = Field(
        ..., description='Model used for reranking', example='rerank-english-v3.0'
    )
    usage: RerankUsage


class Auth0(BaseModel):
    auth_domain: Optional[str] = None
    auth_app_id: Optional[str] = None


class Authing(BaseModel):
    auth_domain: Optional[str] = None
    auth_app_id: Optional[str] = None


class Logto(BaseModel):
    auth_domain: Optional[str] = None
    auth_app_id: Optional[str] = None


class Auth(BaseModel):
    type: Optional[Literal['none', 'auth0', 'authing', 'logto', 'cookie']] = None
    auth0: Optional[Auth0] = None
    authing: Optional[Authing] = None
    logto: Optional[Logto] = None


class Config(BaseModel):
    admin_user_exists: Optional[bool] = Field(
        None, description='Whether the admin user exists'
    )
    auth: Optional[Auth] = None


class PromptTemplate(BaseModel):
    name: Optional[str] = None
    prompt: Optional[str] = None
    description: Optional[str] = None


class PromptTemplateList(BaseModel):
    """
    A list of prompt templates
    """

    items: Optional[list[PromptTemplate]] = None
    pageResult: Optional[PageResult] = None


class AuditLog(BaseModel):
    """
    Audit log entry
    """

    id: Optional[str] = Field(None, description='Audit log ID')
    user_id: Optional[str] = Field(None, description='User ID who performed the action')
    username: Optional[str] = Field(None, description='Username for display')
    resource_type: Optional[
        Literal[
            'collection',
            'document',
            'bot',
            'chat',
            'message',
            'api_key',
            'llm',
            'llm_provider',
            'llm_provider_model',
            'model_service_provider',
            'user',
            'flow',
            'search',
        ]
    ] = Field(None, description='Type of resource')
    resource_id: Optional[str] = Field(
        None, description='ID of the resource (extracted at query time)'
    )
    api_name: Optional[str] = Field(None, description='API operation name')
    http_method: Optional[str] = Field(
        None, description='HTTP method (POST, PUT, DELETE)'
    )
    path: Optional[str] = Field(None, description='API path')
    status_code: Optional[int] = Field(None, description='HTTP status code')
    start_time: Optional[int] = Field(
        None, description='Request start time (milliseconds since epoch)'
    )
    end_time: Optional[int] = Field(
        None, description='Request end time (milliseconds since epoch)'
    )
    duration_ms: Optional[int] = Field(
        None, description='Request duration in milliseconds (calculated)'
    )
    request_data: Optional[str] = Field(None, description='Request data (JSON string)')
    response_data: Optional[str] = Field(
        None, description='Response data (JSON string)'
    )
    error_message: Optional[str] = Field(None, description='Error message if failed')
    ip_address: Optional[str] = Field(None, description='Client IP address')
    user_agent: Optional[str] = Field(None, description='User agent string')
    request_id: Optional[str] = Field(None, description='Request ID for tracking')
    created: Optional[datetime] = Field(None, description='Created timestamp')


class AuditLogList(BaseModel):
    """
    List of audit logs
    """

    items: Optional[list[AuditLog]] = Field(None, description='Audit log entries')


class InvitationCreate(BaseModel):
    username: Optional[str] = Field(None, description='The username of the user')
    email: Optional[str] = Field(None, description='The email of the user')
    role: Optional[Literal['admin', 'rw', 'ro']] = Field(
        None, description='The role of the user (admin, rw, ro)'
    )


class Invitation(BaseModel):
    email: Optional[str] = Field(None, description='The email of the user')
    token: Optional[str] = Field(None, description='The token of the invitation')
    created_by: Optional[str] = Field(
        None, description='The ID of the user who created the invitation'
    )
    created_at: Optional[str] = Field(
        None, description='The date and time the invitation was created'
    )
    is_valid: Optional[bool] = Field(
        None, description='Whether the invitation is valid'
    )
    used_at: Optional[str] = Field(
        None, description='The date and time the invitation was used'
    )
    role: Optional[Literal['admin', 'rw', 'ro']] = Field(
        None, description='The role of the user (admin, rw, ro)'
    )
    expires_at: Optional[str] = Field(
        None, description='The date and time the invitation will expire'
    )


class InvitationList(BaseModel):
    """
    A list of invitations
    """

    items: Optional[list[Invitation]] = None
    pageResult: Optional[PageResult] = None


class Register(BaseModel):
    """
    The email of the user
    """

    token: Optional[str] = Field(None, description='The invitation token')
    email: Optional[str] = Field(None, description='The email of the user')
    username: Optional[str] = Field(None, description='The username of the user')
    password: Optional[str] = Field(None, description='The password of the user')


class User(BaseModel):
    id: Optional[str] = Field(None, description='The ID of the user')
    username: Optional[str] = Field(None, description='The username of the user')
    email: Optional[str] = Field(None, description='The email of the user')
    role: Optional[str] = Field(None, description='The role of the user')
    is_active: Optional[bool] = Field(None, description='Whether the user is active')
    date_joined: Optional[str] = Field(
        None, description='The date and time the user joined the system'
    )


class Login(BaseModel):
    username: Optional[str] = Field(None, description='The username of the user')
    password: Optional[str] = Field(None, description='The password of the user')


class UserList(BaseModel):
    """
    A list of users
    """

    items: Optional[list[User]] = None
    pageResult: Optional[PageResult] = None


class ChangePassword(BaseModel):
    username: Optional[str] = Field(None, description='The username of the user')
    old_password: Optional[str] = Field(
        None, description='The old password of the user'
    )
    new_password: Optional[str] = Field(
        None, description='The new password of the user'
    )


class WebSearchRequest(BaseModel):
    """
    Web search request
    """

    query: str = Field(..., description='Search query', example='ApeRAG 2025年最新发展')
    max_results: Optional[int] = Field(
        5, description='Maximum number of results to return', example=5
    )
    search_engine: Optional[str] = Field(
        'duckduckgo', description='Search engine to use', example='duckduckgo'
    )
    timeout: Optional[int] = Field(
        30, description='Request timeout in seconds', example=30
    )
    locale: Optional[str] = Field(
        'zh-CN', description='Browser locale', example='zh-CN'
    )


class WebSearchResultItem(BaseModel):
    """
    Individual web search result
    """

    rank: int = Field(..., description='Result rank', example=1)
    title: str = Field(..., description='Page title', example='ApeRAG 2025年技术路线图')
    url: str = Field(
        ..., description='Page URL', example='https://example.com/aperag-2025-roadmap'
    )
    snippet: str = Field(
        ..., description='Page snippet', example='ApeRAG在2025年将重点发展...'
    )
    domain: str = Field(..., description='Domain name', example='example.com')
    timestamp: Optional[datetime] = Field(
        None, description='Result timestamp', example='2025-01-01T00:00:00Z'
    )


class WebSearchResponse(BaseModel):
    """
    Web search response
    """

    query: str = Field(..., description='Original search query')
    results: list[WebSearchResultItem] = Field(
        ..., description='List of search results'
    )
    search_engine: str = Field(..., description='Search engine used')
    total_results: Optional[int] = Field(
        None, description='Total number of results found'
    )
    search_time: Optional[float] = Field(None, description='Search time in seconds')


class WebReadRequest(BaseModel):
    """
    Web content reading request
    """

    urls: Union[str, list[str]] = Field(..., description='URL or list of URLs to read')
    timeout: Optional[int] = Field(
        30, description='Request timeout in seconds', example=30
    )
    locale: Optional[str] = Field(
        'zh-CN', description='Browser locale', example='zh-CN'
    )
    max_concurrent: Optional[int] = Field(
        3, description='Maximum concurrent requests for multiple URLs', example=3
    )


class WebReadResultItem(BaseModel):
    """
    Individual web content reading result
    """

    url: str = Field(..., description='Requested URL')
    status: Literal['success', 'error'] = Field(..., description='Processing status')
    title: Optional[str] = Field(None, description='Page title')
    content: Optional[str] = Field(
        None, description='Extracted content in Markdown format'
    )
    extracted_at: Optional[datetime] = Field(
        None, description='Content extraction timestamp'
    )
    word_count: Optional[int] = Field(None, description='Word count of content')
    token_count: Optional[int] = Field(None, description='Estimated token count')
    error: Optional[str] = Field(None, description='Error message if failed')
    error_code: Optional[str] = Field(None, description='Error code if failed')


class WebReadResponse(BaseModel):
    """
    Web content reading response
    """

    results: list[WebReadResultItem] = Field(..., description='List of reading results')
    total_urls: int = Field(..., description='Total number of URLs processed')
    successful: int = Field(..., description='Number of successful extractions')
    failed: int = Field(..., description='Number of failed extractions')
    processing_time: Optional[float] = Field(
        None, description='Total processing time in seconds'
    )
